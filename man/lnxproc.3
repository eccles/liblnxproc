.\" Copyright (c) 2023 Paul Hewlett <phewlett76@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.TH LNXPROC 3 2013-05-16 "Linux" "Linux Programmer's Manual"
.SH NAME
.nf
lnxproc \- interface to reading the /proc/ & /sys filesystems
.fi
.SH SYNOPSIS
.nf
.BI #include " "<lnxproc/lnxproc.h>

.BI "int lnxproc_new(LNXPROC_MODULE_T **" moduleptr ", size_t " nmodule);

.BI "int lnxproc_set(LNXPROC_MODULE_T *" module , 
.BI "                size_t " pos , 
.BI "                LNXPROC_MODULE_TYPE_T " type , 
.BI "                void *" optional , 
.BI "                size_t " optlen "); "

.BI "int lnxproc_free(LNXPROC_MODULE_T **" modulesptr ");"

.BI "LNXPROC_FREE(" b ")"

.BI "int lnxproc_read(LNXPROC_MODULE_T *" modules ");"

.BI "int lnxproc_print(LNXPROC_MODULE_T *" modules ");"

.BI "int lnxproc_performance(LNXPROC_MODULE_T *" modules ,
.BI "                        long *" rawread_time ,
.BI "                        long *" map_time , 
.BI "                        long *" normalize_time ,
.BI "                        long *" hash_time ");"

.BI "typedef (*LNXPROC_INTERFACE_METHOD)(char *" module , 
.BI "                                    char *" key ,
.BI "                                    char *" value ,
.BI "                                    void *" data ");"

.BI "int lnxproc_iterate(LNXPROC_MODULE_T *" modules ,
.BI "                    LNXPROC_INTERFACE_METHOD " func ,
.BI "                    void *" data ");"

.BI "int lnxproc_fetch(LNXPROC_MODULE_T *" modules ,
.BI "                  LNXPROC_MODULE_TYPE_T " type ,
.BI "                  char *" value ,
.BI "                  size_t " valuelen ");"

.BI "const char *lnxproc_strerror(int " err, 
.BI "                             char *" buf, 
.BI "                             size_t " buflen ");"

.fi
.sp
Compile and link with \fI\-llnxproc\fP.
.SH DESCRIPTION
.P
.BR lnxproc_new ()
creates a module containing
.B nmodule 
entries. 
If 
.B nmodule
is 0 then all modules are loaded and no subsequent calls to
.B lnxproc_set()
are required.
If
.B nmodule
is positive then
.B nmodule
calls to
.B lnxproc_set()
must be executed for each entry in the 
.B modules
argument.
.P
.BR lnxproc_set()
sets the values of an entry in the 
.B modules
argument. 
.B pos
indicates the index of the entry,
.B type
indicates which module and corresponds to a particular file or files to be read from
the /proc or /sys filesystems.

The type field is an enumerated field. The following table shows each module
type together with other characteristics:

.TP
.B LNXPROC_PROC_BUDDYINFO    
reads the /proc/buddyinfo file.
.TP
.B LNXPROC_PROC_CGROUPS    
reads the /proc/cgroups file.
.TP
.B LNXPROC_PROC_CMDLINE    
reads the /proc/cmdline file.
.TP
.B LNXPROC_PROC_CPUINFO    
reads the /proc/cpuinfo file.
.TP
.B LNXPROC_PROC_DISKSTATS
reads the /proc/diskstats file.
.TP
.B LNXPROC_PROC_DOMAINNAME 
reads the /proc/sys/kernel/domainname file. This call is memoized \- second and
subsequent reads always return the same value.
.TP
.B LNXPROC_PROC_INTERRUPTS
reads the /proc/interrupts file.
.TP
.B LNXPROC_PROC_HOSTNAME
reads the /proc/sys/kernel/hostname file. This call is memoized \- second and
subsequent reads always return the same value.
.TP
.B LNXPROC_PROC_LOADAVG
reads the /proc/loadavg file.
.TP
.B LNXPROC_PROC_MEMINFO
reads the /proc/meminfo file.
.TP
.B LNXPROC_PROC_OSRELEASE
reads the /proc/sys/kernel/osrelease file. This call is memoized \- second and
subsequent reads always return the same value.
.TP
.B LNXPROC_PROC_PID_ENVIRON
reads the
/proc/[1-9]*/environ
files. 
The 
.B optional
field is a glob pattern that can specify a subset of pids e.g. specifying
.B '12345'
will only return results for the pid 12345.
.B optlen
parameter must include the terminating NUL e.g. 
.B 1 + strlen(optional)
\.
.TP
.B LNXPROC_PROC_PID_STAT
reads the
/proc/[1-9]*/stat
files. 
The 
.B optional
field is a glob pattern that can specify a subset of pids e.g. specifying
.B '12345'
will only return results for the pid 12345.
.B optlen
parameter must include the terminating NUL e.g. 
.B 1 + strlen(optional)
\.
.TP
.B LNXPROC_SYS_CPUFREQ
reads the
/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq
file. This call is memoized \- second and
subsequent reads always return the same value.
.TP
.B LNXPROC_SYS_DISKSECTORS
reads the
/sys/block/*/queue/hw_sector_size
files. This call is memoized \- second and
subsequent reads always return the same values.
The 
.B optional
field is a glob pattern that can specify a subset of disks e.g. specifying
.B 'sd*'
will only return results for local hard disks. The
.B optlen
parameter must include the terminating NUL e.g. 
.B 1 + strlen(optional)
\.
.P
.BR lnxproc_read()
reads all files corresponding to all
.B modules
in the 
.B modules
argument.
The first call to
.B lnxproc_read()
may be slow as the internal buffers are 
.B grown
to accommodate the data read. Also any time-derived values such as % usage
and/or rates are only calculated from the second call onwards. 
.P
.BR lnxproc_free()
frees all allocated memory for
.B modules
and nullifies the 
.B modules 
pointer
.P
.BR LNXPROC_FREE()
macro version of
.B lnxproc_free()
.P
.BR lnxproc_print()
print to stdout all data collected on the last call to
.B lnxproc_read()
.P
.BR lnxproc_performance()
prints to stdout the time taken to read and process the data in read, map,
normalize and hash phases.
.P
.BR lnxproc_iterate()
iterates over the whole datatset, executing the supplied function on every data
point found.
.P
.BR lnxproc_fetch()
fetches the data for the specified module and key.
.P
.BR lnxproc_strerror()
formats any return values as a string.
.SH RETURN VALUE
On success, all routines return zero.
Negative return values correspond to system error i.e. -errno.
Positive return values are described below.
.SH ERRORS
.TP
.B LNXPROC_OK
No error
.TP
.B LNXPROC_ERROR_MISMATCHED_STRINGS
Internal error - indicates an inconsistency in the error submodule
.TP
.B LNXPROC_ERROR_MALLOC
A malloc,realloc,calloc call has returned NULL.
.TP
.B LNXPROC_ERROR_ILLEGAL_ARG
A function argument is illegal. This includes cases where an argument
may have subfields that are illegal.
.TP
.B LNXPROC_ERROR_BASE_READ_OVERFLOW
Internal error to indicate when to grow buffers to accommodate the quantity
read.
This error is never returned to the user.
.TP
.B LNXPROC_ERROR_BASE_REGEX_FAILURE
The regular expression matcher has failed and is unable to extract the 
field data. Only some modules (
.B LNXPROC_SYS_DISKSECTORS & LNXPROC_PID_STAT
at time of writing ) use file globbing.
.TP
.B LNXPROC_ERROR_BASE_GLOB_FAILURE
The globbing expression matcher has failed and has returned no files matched.
Only some modules (
.B LNXPROC_SYS_DISKSECTORS & LNXPROC_PID_STAT
at time of writing ) use file globbing.
.TP
.B LNXPROC_ERROR_NOT_FOUND
Requested group/key does not exist in the data read from the /proc and/or
/sys filesystems.
.TP
.B LNXPROC_ERROR_BASE_READ_SSIZE_MAX
Read request exceeds system limit SSIZE_MAX.
.SH ENVIRONMENT
The environment variable 
.B LNXPROC_TESTROOT
will be prepended to all files opened and closed by the
.B lnxproc
library. This environment variable is only set when testing the library against
a fixed set of /proc and /sys files located on a normal filesystem.
.SH FILES
.TP
TBD
.SH VERSIONS
.TP
TBD
.SH NOTES
.TP
Currently the key field of the hashtable produced by all the modules of lnxproc has
a hardwired limit of 48 characters. When adding a new module please ensure that any
generated keys are are either not longer than this or increase the key length
limit.
.SH BUGS
The 
.B lnxproc
library was tested on Ubuntu 12.04 and 13.04 using valgrind. 
The code is designed to work on earlier versions of the kernel. 
Some modules may not work and such cases should be reported to the author.
.SH EXAMPLE
The program below demonstrates the use of
.BR lnxproc_new (),
as well as a number of other functions in the lnxproc API.

.fi
.in
.SS Program source
\&
.nf

#include <stdio.h>
#include <string.h>             // strrchr()
#include <sys/time.h>
#include <sys/types.h>          // getpid()
#include <unistd.h>             // getpid()

#include <lnxproc/lnxproc.h>

static const int ntimes = 1000;

static void
test_module(LNXPROC_MODULE_T * modules, char *str)
{
    if (modules) {
        char buf[96];
        LNXPROC_ERROR_T ret = lnxproc_read(modules);

        ret = lnxproc_read(modules);
        if (ret) {
            printf("Error %s\\n", lnxproc_strerror(ret, buf, sizeof buf));
        }
        ret = lnxproc_read(modules);
        if (ret) {
            printf("Error %s\\n", lnxproc_strerror(ret, buf, sizeof buf));
        }

        long rawread_time;
        long map_time;
        long hash_time;
        long normalize_time;
        float sum_rawread_time = 0;
        float sum_map_time = 0;
        float sum_hash_time = 0;
        float sum_normalize_time = 0;
        struct timeval start = lnxproc_timeval();

        int i;

        for (i = 0; i < ntimes; i++) {
            ret = lnxproc_read(modules);
            if (ret) {
                printf("%s:Error %s\\n", str,
                       lnxproc_strerror(ret, buf, sizeof buf));
                break;
            }
            lnxproc_performance(modules, &rawread_time, &map_time,
                                &hash_time, &normalize_time);
            sum_rawread_time += rawread_time;
            sum_map_time += map_time;
            sum_hash_time += hash_time;
            sum_normalize_time += normalize_time;
        }

        struct timeval end = lnxproc_timeval();
        long timediff = lnxproc_timeval_diff(&start, &end);

        printf("%s:Elapsed time = %.1f usecs (%.1f,%.1f,%.1f,%.1f)\\n", 
               str,
               (timediff * 1.0) / ntimes, sum_rawread_time / ntimes,
               sum_map_time / ntimes, sum_hash_time / ntimes,
               sum_normalize_time / ntimes);
    }
}

/*---------------------------------------------------------------------*/
int
main(int argc, char *argv[])
{
    /* NB Omit return values for clarity */

    lnxproc_new(&modules, 0); // load all modules
    test_module(modules, "All");
    LNXPROC_FREE(modules);

    lnxproc_new(&modules, 1); // only read /proc/cgroups
    lnxproc_set(modules, 0, LNXPROC_PROC_CGROUPS, NULL, 0);
    test_module(modules, "proc_cgroups");
    LNXPROC_FREE(modules);

    lnxproc_new(&modules, 2); // read /proc/groups and 
                              // /proc/diskstats simultaneously
    lnxproc_set(modules, 0, LNXPROC_PROC_CGROUPS, NULL, 0);
    lnxproc_set(modules, 1, LNXPROC_PROC_DISKSTATS, NULL, 0);
    test_module(modules, "proc_diskstats");
    LNXPROC_FREE(modules);

    lnxproc_new(&modules, 1); // Domainname - the value is memoized
    lnxproc_set(modules, 0, LNXPROC_PROC_DOMAINNAME, NULL, 0);
    test_module(modules, "proc_domainname");
    LNXPROC_FREE(modules);

    lnxproc_new(&modules, 1); // Get sector size for every disk 
                              // memoized
    lnxproc_set(modules, 0, LNXPROC_SYS_DISKSECTORS, NULL, 0);
    test_module(modules, "sys_disksectors");
    LNXPROC_FREE(modules);

    lnxproc_new(&modules, 1); // get sector size for esata disks
    lnxproc_set(modules, 0, LNXPROC_SYS_DISKSECTORS, "sd*", 4);
    test_module(modules, "sys_sd_disksectors");
    LNXPROC_FREE(modules);

    lnxproc_new(&modules, 1); // Read /proc/<pid>/stat file for 
                              // every process
    lnxproc_set(modules, 0, LNXPROC_PROC_PID_STAT, NULL, 0);
    test_module(modules, "proc_pid_stat");
    LNXPROC_FREE(modules);

    char buf[32];

    snprintf(buf, sizeof buf, "%d", getpid());
    lnxproc_new(&modules, 1); // Read /proc/<pid>/stat file for 
                              // this process
    lnxproc_set(modules, 0, LNXPROC_PROC_PID_STAT, buf, 1 + strlen(buf));
    snprintf(buf, sizeof buf, "proc_%d_stat", getpid());
    test_module(modules, buf);
    LNXPROC_FREE(modules);

    return 0;
}
.fi
.SH SEE ALSO
.TP
TBD
.SH COLOPHON
A description of the project,
and information about reporting bugs,
can be found at
http://www.github.com/eccles/liblnxproc/.
